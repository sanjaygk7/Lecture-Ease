{"version":3,"sources":["../../../../src/app-router/server/auth.ts"],"sourcesContent":["import type { AuthObject } from '@clerk/backend';\nimport { constants, createClerkRequest, createRedirect, type RedirectFun } from '@clerk/backend/internal';\nimport { notFound, redirect } from 'next/navigation';\n\nimport { PUBLISHABLE_KEY, SIGN_IN_URL, SIGN_UP_URL } from '../../server/constants';\nimport { createGetAuth } from '../../server/createGetAuth';\nimport { authAuthHeaderMissing } from '../../server/errors';\nimport type { AuthProtect } from '../../server/protect';\nimport { createProtect } from '../../server/protect';\nimport { decryptClerkRequestData, getAuthKeyFromRequest, getHeader } from '../../server/utils';\nimport { buildRequestLike } from './utils';\n\ntype Auth = AuthObject & { redirectToSignIn: RedirectFun<ReturnType<typeof redirect>> };\n\nexport interface AuthFn {\n  (): Promise<Auth>;\n  protect: AuthProtect;\n}\n\nexport const auth: AuthFn = async () => {\n  require('server-only');\n\n  const request = await buildRequestLike();\n  const authObject = createGetAuth({\n    debugLoggerName: 'auth()',\n    noAuthStatusMessage: authAuthHeaderMissing(),\n  })(request);\n\n  const clerkUrl = getAuthKeyFromRequest(request, 'ClerkUrl');\n\n  const redirectToSignIn: RedirectFun<never> = (opts = {}) => {\n    const clerkRequest = createClerkRequest(request);\n    const devBrowserToken =\n      clerkRequest.clerkUrl.searchParams.get(constants.QueryParameters.DevBrowser) ||\n      clerkRequest.cookies.get(constants.Cookies.DevBrowser);\n\n    const encryptedRequestData = getHeader(request, constants.Headers.ClerkRequestData);\n    const decryptedRequestData = decryptClerkRequestData(encryptedRequestData);\n\n    return createRedirect({\n      redirectAdapter: redirect,\n      devBrowserToken: devBrowserToken,\n      baseUrl: clerkRequest.clerkUrl.toString(),\n      publishableKey: decryptedRequestData.publishableKey || PUBLISHABLE_KEY,\n      signInUrl: decryptedRequestData.signInUrl || SIGN_IN_URL,\n      signUpUrl: decryptedRequestData.signUpUrl || SIGN_UP_URL,\n    }).redirectToSignIn({\n      returnBackUrl: opts.returnBackUrl === null ? '' : opts.returnBackUrl || clerkUrl?.toString(),\n    });\n  };\n\n  return Object.assign(authObject, { redirectToSignIn });\n};\n\nauth.protect = async (...args) => {\n  require('server-only');\n\n  const request = await buildRequestLike();\n  const authObject = await auth();\n\n  const protect = createProtect({\n    request,\n    authObject,\n    redirectToSignIn: authObject.redirectToSignIn,\n    notFound,\n    redirect,\n  });\n\n  // @ts-expect-error TS flattens all possible combinations of the for AuthProtect signatures in a union.\n  return protect(...args);\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,sBAAgF;AAChF,wBAAmC;AAEnC,uBAA0D;AAC1D,2BAA8B;AAC9B,oBAAsC;AAEtC,qBAA8B;AAC9B,mBAA0E;AAC1E,IAAAA,gBAAiC;AAS1B,MAAM,OAAe,YAAY;AACtC,UAAQ,aAAa;AAErB,QAAM,UAAU,UAAM,gCAAiB;AACvC,QAAM,iBAAa,oCAAc;AAAA,IAC/B,iBAAiB;AAAA,IACjB,yBAAqB,qCAAsB;AAAA,EAC7C,CAAC,EAAE,OAAO;AAEV,QAAM,eAAW,oCAAsB,SAAS,UAAU;AAE1D,QAAM,mBAAuC,CAAC,OAAO,CAAC,MAAM;AAC1D,UAAM,mBAAe,oCAAmB,OAAO;AAC/C,UAAM,kBACJ,aAAa,SAAS,aAAa,IAAI,0BAAU,gBAAgB,UAAU,KAC3E,aAAa,QAAQ,IAAI,0BAAU,QAAQ,UAAU;AAEvD,UAAM,2BAAuB,wBAAU,SAAS,0BAAU,QAAQ,gBAAgB;AAClF,UAAM,2BAAuB,sCAAwB,oBAAoB;AAEzE,eAAO,gCAAe;AAAA,MACpB,iBAAiB;AAAA,MACjB;AAAA,MACA,SAAS,aAAa,SAAS,SAAS;AAAA,MACxC,gBAAgB,qBAAqB,kBAAkB;AAAA,MACvD,WAAW,qBAAqB,aAAa;AAAA,MAC7C,WAAW,qBAAqB,aAAa;AAAA,IAC/C,CAAC,EAAE,iBAAiB;AAAA,MAClB,eAAe,KAAK,kBAAkB,OAAO,KAAK,KAAK,kBAAiB,qCAAU;AAAA,IACpF,CAAC;AAAA,EACH;AAEA,SAAO,OAAO,OAAO,YAAY,EAAE,iBAAiB,CAAC;AACvD;AAEA,KAAK,UAAU,UAAU,SAAS;AAChC,UAAQ,aAAa;AAErB,QAAM,UAAU,UAAM,gCAAiB;AACvC,QAAM,aAAa,MAAM,KAAK;AAE9B,QAAM,cAAU,8BAAc;AAAA,IAC5B;AAAA,IACA;AAAA,IACA,kBAAkB,WAAW;AAAA,IAC7B;AAAA,IACA;AAAA,EACF,CAAC;AAGD,SAAO,QAAQ,GAAG,IAAI;AACxB;","names":["import_utils"]}