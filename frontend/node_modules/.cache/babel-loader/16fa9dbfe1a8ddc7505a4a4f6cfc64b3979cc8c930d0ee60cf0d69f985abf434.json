{"ast":null,"code":"import { ERROR_RESPONSE_BODY_READER, ERROR_INCOMPLETED_DOWNLOAD } from \"./errors.js\";\nimport { HeaderContentLength } from \"./const.js\";\nconst readFromBlobOrFile = blob => new Promise((resolve, reject) => {\n  const fileReader = new FileReader();\n  fileReader.onload = () => {\n    const {\n      result\n    } = fileReader;\n    if (result instanceof ArrayBuffer) {\n      resolve(new Uint8Array(result));\n    } else {\n      resolve(new Uint8Array());\n    }\n  };\n  fileReader.onerror = event => {\n    reject(Error(`File could not be read! Code=${event?.target?.error?.code || -1}`));\n  };\n  fileReader.readAsArrayBuffer(blob);\n});\n/**\n * An util function to fetch data from url string, base64, URL, File or Blob format.\n *\n * Examples:\n * ```ts\n * // URL\n * await fetchFile(\"http://localhost:3000/video.mp4\");\n * // base64\n * await fetchFile(\"data:<type>;base64,wL2dvYWwgbW9yZ...\");\n * // URL\n * await fetchFile(new URL(\"video.mp4\", import.meta.url));\n * // File\n * fileInput.addEventListener('change', (e) => {\n *   await fetchFile(e.target.files[0]);\n * });\n * // Blob\n * const blob = new Blob(...);\n * await fetchFile(blob);\n * ```\n */\nexport const fetchFile = async file => {\n  let data;\n  if (typeof file === \"string\") {\n    /* From base64 format */\n    if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(file)) {\n      data = atob(file.split(\",\")[1]).split(\"\").map(c => c.charCodeAt(0));\n      /* From remote server/URL */\n    } else {\n      data = await (await fetch(file)).arrayBuffer();\n    }\n  } else if (file instanceof URL) {\n    data = await (await fetch(file)).arrayBuffer();\n  } else if (file instanceof File || file instanceof Blob) {\n    data = await readFromBlobOrFile(file);\n  } else {\n    return new Uint8Array();\n  }\n  return new Uint8Array(data);\n};\n/**\n * importScript dynamically import a script, useful when you\n * want to use different versions of ffmpeg.wasm based on environment.\n *\n * Example:\n *\n * ```ts\n * await importScript(\"http://localhost:3000/ffmpeg.js\");\n * ```\n */\nexport const importScript = async url => new Promise(resolve => {\n  const script = document.createElement(\"script\");\n  const eventHandler = () => {\n    script.removeEventListener(\"load\", eventHandler);\n    resolve();\n  };\n  script.src = url;\n  script.type = \"text/javascript\";\n  script.addEventListener(\"load\", eventHandler);\n  document.getElementsByTagName(\"head\")[0].appendChild(script);\n});\n/**\n * Download content of a URL with progress.\n *\n * Progress only works when Content-Length is provided by the server.\n *\n */\nexport const downloadWithProgress = async (url, cb) => {\n  const resp = await fetch(url);\n  let buf;\n  try {\n    // Set total to -1 to indicate that there is not Content-Type Header.\n    const total = parseInt(resp.headers.get(HeaderContentLength) || \"-1\");\n    const reader = resp.body?.getReader();\n    if (!reader) throw ERROR_RESPONSE_BODY_READER;\n    const chunks = [];\n    let received = 0;\n    for (;;) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      const delta = value ? value.length : 0;\n      if (done) {\n        if (total != -1 && total !== received) throw ERROR_INCOMPLETED_DOWNLOAD;\n        cb && cb({\n          url,\n          total,\n          received,\n          delta,\n          done\n        });\n        break;\n      }\n      chunks.push(value);\n      received += delta;\n      cb && cb({\n        url,\n        total,\n        received,\n        delta,\n        done\n      });\n    }\n    const data = new Uint8Array(received);\n    let position = 0;\n    for (const chunk of chunks) {\n      data.set(chunk, position);\n      position += chunk.length;\n    }\n    buf = data.buffer;\n  } catch (e) {\n    console.log(`failed to send download progress event: `, e);\n    // Fetch arrayBuffer directly when it is not possible to get progress.\n    buf = await resp.arrayBuffer();\n    cb && cb({\n      url,\n      total: buf.byteLength,\n      received: buf.byteLength,\n      delta: 0,\n      done: true\n    });\n  }\n  return buf;\n};\n/**\n * toBlobURL fetches data from an URL and return a blob URL.\n *\n * Example:\n *\n * ```ts\n * await toBlobURL(\"http://localhost:3000/ffmpeg.js\", \"text/javascript\");\n * ```\n */\nexport const toBlobURL = async (url, mimeType, progress = false, cb) => {\n  const buf = progress ? await downloadWithProgress(url, cb) : await (await fetch(url)).arrayBuffer();\n  const blob = new Blob([buf], {\n    type: mimeType\n  });\n  return URL.createObjectURL(blob);\n};","map":{"version":3,"names":["ERROR_RESPONSE_BODY_READER","ERROR_INCOMPLETED_DOWNLOAD","HeaderContentLength","readFromBlobOrFile","blob","Promise","resolve","reject","fileReader","FileReader","onload","result","ArrayBuffer","Uint8Array","onerror","event","Error","target","error","code","readAsArrayBuffer","fetchFile","file","data","test","atob","split","map","c","charCodeAt","fetch","arrayBuffer","URL","File","Blob","importScript","url","script","document","createElement","eventHandler","removeEventListener","src","type","addEventListener","getElementsByTagName","appendChild","downloadWithProgress","cb","resp","buf","total","parseInt","headers","get","reader","body","getReader","chunks","received","done","value","read","delta","length","push","position","chunk","set","buffer","e","console","log","byteLength","toBlobURL","mimeType","progress","createObjectURL"],"sources":["D:/Project/Mini-Project/node_modules/@ffmpeg/util/dist/esm/index.js"],"sourcesContent":["import { ERROR_RESPONSE_BODY_READER, ERROR_INCOMPLETED_DOWNLOAD, } from \"./errors.js\";\nimport { HeaderContentLength } from \"./const.js\";\nconst readFromBlobOrFile = (blob) => new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n        const { result } = fileReader;\n        if (result instanceof ArrayBuffer) {\n            resolve(new Uint8Array(result));\n        }\n        else {\n            resolve(new Uint8Array());\n        }\n    };\n    fileReader.onerror = (event) => {\n        reject(Error(`File could not be read! Code=${event?.target?.error?.code || -1}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n});\n/**\n * An util function to fetch data from url string, base64, URL, File or Blob format.\n *\n * Examples:\n * ```ts\n * // URL\n * await fetchFile(\"http://localhost:3000/video.mp4\");\n * // base64\n * await fetchFile(\"data:<type>;base64,wL2dvYWwgbW9yZ...\");\n * // URL\n * await fetchFile(new URL(\"video.mp4\", import.meta.url));\n * // File\n * fileInput.addEventListener('change', (e) => {\n *   await fetchFile(e.target.files[0]);\n * });\n * // Blob\n * const blob = new Blob(...);\n * await fetchFile(blob);\n * ```\n */\nexport const fetchFile = async (file) => {\n    let data;\n    if (typeof file === \"string\") {\n        /* From base64 format */\n        if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(file)) {\n            data = atob(file.split(\",\")[1])\n                .split(\"\")\n                .map((c) => c.charCodeAt(0));\n            /* From remote server/URL */\n        }\n        else {\n            data = await (await fetch(file)).arrayBuffer();\n        }\n    }\n    else if (file instanceof URL) {\n        data = await (await fetch(file)).arrayBuffer();\n    }\n    else if (file instanceof File || file instanceof Blob) {\n        data = await readFromBlobOrFile(file);\n    }\n    else {\n        return new Uint8Array();\n    }\n    return new Uint8Array(data);\n};\n/**\n * importScript dynamically import a script, useful when you\n * want to use different versions of ffmpeg.wasm based on environment.\n *\n * Example:\n *\n * ```ts\n * await importScript(\"http://localhost:3000/ffmpeg.js\");\n * ```\n */\nexport const importScript = async (url) => new Promise((resolve) => {\n    const script = document.createElement(\"script\");\n    const eventHandler = () => {\n        script.removeEventListener(\"load\", eventHandler);\n        resolve();\n    };\n    script.src = url;\n    script.type = \"text/javascript\";\n    script.addEventListener(\"load\", eventHandler);\n    document.getElementsByTagName(\"head\")[0].appendChild(script);\n});\n/**\n * Download content of a URL with progress.\n *\n * Progress only works when Content-Length is provided by the server.\n *\n */\nexport const downloadWithProgress = async (url, cb) => {\n    const resp = await fetch(url);\n    let buf;\n    try {\n        // Set total to -1 to indicate that there is not Content-Type Header.\n        const total = parseInt(resp.headers.get(HeaderContentLength) || \"-1\");\n        const reader = resp.body?.getReader();\n        if (!reader)\n            throw ERROR_RESPONSE_BODY_READER;\n        const chunks = [];\n        let received = 0;\n        for (;;) {\n            const { done, value } = await reader.read();\n            const delta = value ? value.length : 0;\n            if (done) {\n                if (total != -1 && total !== received)\n                    throw ERROR_INCOMPLETED_DOWNLOAD;\n                cb && cb({ url, total, received, delta, done });\n                break;\n            }\n            chunks.push(value);\n            received += delta;\n            cb && cb({ url, total, received, delta, done });\n        }\n        const data = new Uint8Array(received);\n        let position = 0;\n        for (const chunk of chunks) {\n            data.set(chunk, position);\n            position += chunk.length;\n        }\n        buf = data.buffer;\n    }\n    catch (e) {\n        console.log(`failed to send download progress event: `, e);\n        // Fetch arrayBuffer directly when it is not possible to get progress.\n        buf = await resp.arrayBuffer();\n        cb &&\n            cb({\n                url,\n                total: buf.byteLength,\n                received: buf.byteLength,\n                delta: 0,\n                done: true,\n            });\n    }\n    return buf;\n};\n/**\n * toBlobURL fetches data from an URL and return a blob URL.\n *\n * Example:\n *\n * ```ts\n * await toBlobURL(\"http://localhost:3000/ffmpeg.js\", \"text/javascript\");\n * ```\n */\nexport const toBlobURL = async (url, mimeType, progress = false, cb) => {\n    const buf = progress\n        ? await downloadWithProgress(url, cb)\n        : await (await fetch(url)).arrayBuffer();\n    const blob = new Blob([buf], { type: mimeType });\n    return URL.createObjectURL(blob);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}