{"ast":null,"code":"/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n/// <reference lib=\"webworker\" />\nimport { CORE_URL, FFMessageType } from \"./const.js\";\nimport { ERROR_UNKNOWN_MESSAGE_TYPE, ERROR_NOT_LOADED, ERROR_IMPORT_FAILURE } from \"./errors.js\";\nlet ffmpeg;\nconst load = async ({\n  coreURL: _coreURL,\n  wasmURL: _wasmURL,\n  workerURL: _workerURL\n}) => {\n  const first = !ffmpeg;\n  try {\n    if (!_coreURL) _coreURL = CORE_URL;\n    // when web worker type is `classic`.\n    importScripts(_coreURL);\n  } catch {\n    if (!_coreURL) _coreURL = CORE_URL.replace('/umd/', '/esm/');\n    // when web worker type is `module`.\n    self.createFFmpegCore = (await import(/* webpackIgnore: true */ /* @vite-ignore */_coreURL)).default;\n    if (!self.createFFmpegCore) {\n      throw ERROR_IMPORT_FAILURE;\n    }\n  }\n  const coreURL = _coreURL;\n  const wasmURL = _wasmURL ? _wasmURL : _coreURL.replace(/.js$/g, \".wasm\");\n  const workerURL = _workerURL ? _workerURL : _coreURL.replace(/.js$/g, \".worker.js\");\n  ffmpeg = await self.createFFmpegCore({\n    // Fix `Overload resolution failed.` when using multi-threaded ffmpeg-core.\n    // Encoded wasmURL and workerURL in the URL as a hack to fix locateFile issue.\n    mainScriptUrlOrBlob: `${coreURL}#${btoa(JSON.stringify({\n      wasmURL,\n      workerURL\n    }))}`\n  });\n  ffmpeg.setLogger(data => self.postMessage({\n    type: FFMessageType.LOG,\n    data\n  }));\n  ffmpeg.setProgress(data => self.postMessage({\n    type: FFMessageType.PROGRESS,\n    data\n  }));\n  return first;\n};\nconst exec = ({\n  args,\n  timeout = -1\n}) => {\n  ffmpeg.setTimeout(timeout);\n  ffmpeg.exec(...args);\n  const ret = ffmpeg.ret;\n  ffmpeg.reset();\n  return ret;\n};\nconst writeFile = ({\n  path,\n  data\n}) => {\n  ffmpeg.FS.writeFile(path, data);\n  return true;\n};\nconst readFile = ({\n  path,\n  encoding\n}) => ffmpeg.FS.readFile(path, {\n  encoding\n});\n// TODO: check if deletion works.\nconst deleteFile = ({\n  path\n}) => {\n  ffmpeg.FS.unlink(path);\n  return true;\n};\nconst rename = ({\n  oldPath,\n  newPath\n}) => {\n  ffmpeg.FS.rename(oldPath, newPath);\n  return true;\n};\n// TODO: check if creation works.\nconst createDir = ({\n  path\n}) => {\n  ffmpeg.FS.mkdir(path);\n  return true;\n};\nconst listDir = ({\n  path\n}) => {\n  const names = ffmpeg.FS.readdir(path);\n  const nodes = [];\n  for (const name of names) {\n    const stat = ffmpeg.FS.stat(`${path}/${name}`);\n    const isDir = ffmpeg.FS.isDir(stat.mode);\n    nodes.push({\n      name,\n      isDir\n    });\n  }\n  return nodes;\n};\n// TODO: check if deletion works.\nconst deleteDir = ({\n  path\n}) => {\n  ffmpeg.FS.rmdir(path);\n  return true;\n};\nconst mount = ({\n  fsType,\n  options,\n  mountPoint\n}) => {\n  const str = fsType;\n  const fs = ffmpeg.FS.filesystems[str];\n  if (!fs) return false;\n  ffmpeg.FS.mount(fs, options, mountPoint);\n  return true;\n};\nconst unmount = ({\n  mountPoint\n}) => {\n  ffmpeg.FS.unmount(mountPoint);\n  return true;\n};\nself.onmessage = async ({\n  data: {\n    id,\n    type,\n    data: _data\n  }\n}) => {\n  const trans = [];\n  let data;\n  try {\n    if (type !== FFMessageType.LOAD && !ffmpeg) throw ERROR_NOT_LOADED; // eslint-disable-line\n    switch (type) {\n      case FFMessageType.LOAD:\n        data = await load(_data);\n        break;\n      case FFMessageType.EXEC:\n        data = exec(_data);\n        break;\n      case FFMessageType.WRITE_FILE:\n        data = writeFile(_data);\n        break;\n      case FFMessageType.READ_FILE:\n        data = readFile(_data);\n        break;\n      case FFMessageType.DELETE_FILE:\n        data = deleteFile(_data);\n        break;\n      case FFMessageType.RENAME:\n        data = rename(_data);\n        break;\n      case FFMessageType.CREATE_DIR:\n        data = createDir(_data);\n        break;\n      case FFMessageType.LIST_DIR:\n        data = listDir(_data);\n        break;\n      case FFMessageType.DELETE_DIR:\n        data = deleteDir(_data);\n        break;\n      case FFMessageType.MOUNT:\n        data = mount(_data);\n        break;\n      case FFMessageType.UNMOUNT:\n        data = unmount(_data);\n        break;\n      default:\n        throw ERROR_UNKNOWN_MESSAGE_TYPE;\n    }\n  } catch (e) {\n    self.postMessage({\n      id,\n      type: FFMessageType.ERROR,\n      data: e.toString()\n    });\n    return;\n  }\n  if (data instanceof Uint8Array) {\n    trans.push(data.buffer);\n  }\n  self.postMessage({\n    id,\n    type,\n    data\n  }, trans);\n};","map":{"version":3,"names":["CORE_URL","FFMessageType","ERROR_UNKNOWN_MESSAGE_TYPE","ERROR_NOT_LOADED","ERROR_IMPORT_FAILURE","ffmpeg","load","coreURL","_coreURL","wasmURL","_wasmURL","workerURL","_workerURL","first","importScripts","replace","self","createFFmpegCore","default","mainScriptUrlOrBlob","btoa","JSON","stringify","setLogger","data","postMessage","type","LOG","setProgress","PROGRESS","exec","args","timeout","setTimeout","ret","reset","writeFile","path","FS","readFile","encoding","deleteFile","unlink","rename","oldPath","newPath","createDir","mkdir","listDir","names","readdir","nodes","name","stat","isDir","mode","push","deleteDir","rmdir","mount","fsType","options","mountPoint","str","fs","filesystems","unmount","onmessage","id","_data","trans","LOAD","EXEC","WRITE_FILE","READ_FILE","DELETE_FILE","RENAME","CREATE_DIR","LIST_DIR","DELETE_DIR","MOUNT","UNMOUNT","e","ERROR","toString","Uint8Array","buffer"],"sources":["D:/Project/Mini-Project/frontend/node_modules/@ffmpeg/ffmpeg/dist/esm/worker.js"],"sourcesContent":["/// <reference no-default-lib=\"true\" />\n/// <reference lib=\"esnext\" />\n/// <reference lib=\"webworker\" />\nimport { CORE_URL, FFMessageType } from \"./const.js\";\nimport { ERROR_UNKNOWN_MESSAGE_TYPE, ERROR_NOT_LOADED, ERROR_IMPORT_FAILURE, } from \"./errors.js\";\nlet ffmpeg;\nconst load = async ({ coreURL: _coreURL, wasmURL: _wasmURL, workerURL: _workerURL, }) => {\n    const first = !ffmpeg;\n    try {\n        if (!_coreURL)\n            _coreURL = CORE_URL;\n        // when web worker type is `classic`.\n        importScripts(_coreURL);\n    }\n    catch {\n        if (!_coreURL)\n            _coreURL = CORE_URL.replace('/umd/', '/esm/');\n        // when web worker type is `module`.\n        self.createFFmpegCore = (await import(\n        /* webpackIgnore: true */ /* @vite-ignore */ _coreURL)).default;\n        if (!self.createFFmpegCore) {\n            throw ERROR_IMPORT_FAILURE;\n        }\n    }\n    const coreURL = _coreURL;\n    const wasmURL = _wasmURL ? _wasmURL : _coreURL.replace(/.js$/g, \".wasm\");\n    const workerURL = _workerURL\n        ? _workerURL\n        : _coreURL.replace(/.js$/g, \".worker.js\");\n    ffmpeg = await self.createFFmpegCore({\n        // Fix `Overload resolution failed.` when using multi-threaded ffmpeg-core.\n        // Encoded wasmURL and workerURL in the URL as a hack to fix locateFile issue.\n        mainScriptUrlOrBlob: `${coreURL}#${btoa(JSON.stringify({ wasmURL, workerURL }))}`,\n    });\n    ffmpeg.setLogger((data) => self.postMessage({ type: FFMessageType.LOG, data }));\n    ffmpeg.setProgress((data) => self.postMessage({\n        type: FFMessageType.PROGRESS,\n        data,\n    }));\n    return first;\n};\nconst exec = ({ args, timeout = -1 }) => {\n    ffmpeg.setTimeout(timeout);\n    ffmpeg.exec(...args);\n    const ret = ffmpeg.ret;\n    ffmpeg.reset();\n    return ret;\n};\nconst writeFile = ({ path, data }) => {\n    ffmpeg.FS.writeFile(path, data);\n    return true;\n};\nconst readFile = ({ path, encoding }) => ffmpeg.FS.readFile(path, { encoding });\n// TODO: check if deletion works.\nconst deleteFile = ({ path }) => {\n    ffmpeg.FS.unlink(path);\n    return true;\n};\nconst rename = ({ oldPath, newPath }) => {\n    ffmpeg.FS.rename(oldPath, newPath);\n    return true;\n};\n// TODO: check if creation works.\nconst createDir = ({ path }) => {\n    ffmpeg.FS.mkdir(path);\n    return true;\n};\nconst listDir = ({ path }) => {\n    const names = ffmpeg.FS.readdir(path);\n    const nodes = [];\n    for (const name of names) {\n        const stat = ffmpeg.FS.stat(`${path}/${name}`);\n        const isDir = ffmpeg.FS.isDir(stat.mode);\n        nodes.push({ name, isDir });\n    }\n    return nodes;\n};\n// TODO: check if deletion works.\nconst deleteDir = ({ path }) => {\n    ffmpeg.FS.rmdir(path);\n    return true;\n};\nconst mount = ({ fsType, options, mountPoint }) => {\n    const str = fsType;\n    const fs = ffmpeg.FS.filesystems[str];\n    if (!fs)\n        return false;\n    ffmpeg.FS.mount(fs, options, mountPoint);\n    return true;\n};\nconst unmount = ({ mountPoint }) => {\n    ffmpeg.FS.unmount(mountPoint);\n    return true;\n};\nself.onmessage = async ({ data: { id, type, data: _data }, }) => {\n    const trans = [];\n    let data;\n    try {\n        if (type !== FFMessageType.LOAD && !ffmpeg)\n            throw ERROR_NOT_LOADED; // eslint-disable-line\n        switch (type) {\n            case FFMessageType.LOAD:\n                data = await load(_data);\n                break;\n            case FFMessageType.EXEC:\n                data = exec(_data);\n                break;\n            case FFMessageType.WRITE_FILE:\n                data = writeFile(_data);\n                break;\n            case FFMessageType.READ_FILE:\n                data = readFile(_data);\n                break;\n            case FFMessageType.DELETE_FILE:\n                data = deleteFile(_data);\n                break;\n            case FFMessageType.RENAME:\n                data = rename(_data);\n                break;\n            case FFMessageType.CREATE_DIR:\n                data = createDir(_data);\n                break;\n            case FFMessageType.LIST_DIR:\n                data = listDir(_data);\n                break;\n            case FFMessageType.DELETE_DIR:\n                data = deleteDir(_data);\n                break;\n            case FFMessageType.MOUNT:\n                data = mount(_data);\n                break;\n            case FFMessageType.UNMOUNT:\n                data = unmount(_data);\n                break;\n            default:\n                throw ERROR_UNKNOWN_MESSAGE_TYPE;\n        }\n    }\n    catch (e) {\n        self.postMessage({\n            id,\n            type: FFMessageType.ERROR,\n            data: e.toString(),\n        });\n        return;\n    }\n    if (data instanceof Uint8Array) {\n        trans.push(data.buffer);\n    }\n    self.postMessage({ id, type, data }, trans);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}